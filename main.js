/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./hive.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./board.js":
/*!******************!*\
  !*** ./board.js ***!
  \******************/
/*! exports provided: Hex, Cube, Space, Hand */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Hex\", function() { return Hex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Cube\", function() { return Cube; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Space\", function() { return Space; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Hand\", function() { return Hand; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./common.js\");\n // Axial coordinates\n\nclass Hex {\n  constructor(q, r) {\n    this.q = q;\n    this.r = r;\n  }\n\n  toCube() {\n    return new Cube(this.q, this.r, -this.q - this.r);\n  }\n\n  round() {\n    return this.toCube().round().toHex();\n  }\n\n  add({\n    q,\n    r\n  }) {\n    return new Hex(this.q + q, this.r + r);\n  }\n\n  sub({\n    q,\n    r\n  }) {\n    return new Hex(this.q - q, this.r - r);\n  }\n\n  eq({\n    q,\n    r\n  }) {\n    return this.q === q && this.r === r;\n  }\n\n  scale(n) {\n    return new Hex(this.q * n, this.r * n);\n  }\n\n  revert() {\n    return this.scale(-1);\n  }\n\n  rotate(n) {\n    return this.toCube().rotate(n).toHex();\n  }\n\n  distance(hex) {\n    return this.toCube().distance(hex.toCube());\n  }\n\n  directionTo(hex) {\n    return this.toCube().directionTo(hex.toCube()).toHex();\n  }\n\n  neighborhood() {\n    return Hex.directions.map(dir => this.add(dir));\n  }\n\n  toString() {\n    return `${this.q};${this.r}`;\n  }\n\n}\nHex.directions = [new Hex(+1, 0), new Hex(+1, -1), new Hex(0, -1), new Hex(-1, 0), new Hex(-1, +1), new Hex(0, +1)]; // Cubic coordinates\n\nclass Cube {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  round() {\n    let rx = Math.round(this.x);\n    let ry = Math.round(this.y);\n    let rz = Math.round(this.z);\n    const dx = Math.abs(rx - this.x);\n    const dy = Math.abs(ry - this.y);\n    const dz = Math.abs(rz - this.z);\n\n    if (dx > dy && dx > dz) {\n      // ensure rx + ry + rz == 0\n      rx = -ry - rz;\n    } else if (dy > dz) {\n      ry = -rx - rz;\n    } else {\n      rz = -rx - ry;\n    }\n\n    return new Cube(rx, ry, rz);\n  }\n\n  toHex() {\n    return new Hex(this.x, this.y);\n  }\n\n  add({\n    x,\n    y,\n    z\n  }) {\n    return new Cube(this.x + x, this.y + y, this.z + z);\n  }\n\n  sub({\n    x,\n    y,\n    z\n  }) {\n    return new Cube(this.x - x, this.y - y, this.z - z);\n  }\n\n  eq({\n    x,\n    y,\n    z\n  }) {\n    return this.x === x && this.y === y && this.z === z;\n  }\n\n  scale(n) {\n    return new Cube(this.x * n, this.y * n, this.z * n);\n  }\n\n  revert() {\n    return this.scale(-1);\n  }\n\n  rotate(n) {\n    n %= 6;\n    n += 6;\n    n %= 6;\n    let c = this;\n\n    while (n--) {\n      c = new Cube(-c.z, -c.x, -c.y);\n    }\n\n    return c;\n  }\n\n  distance({\n    x,\n    y,\n    z\n  }) {\n    return (Math.abs(this.x - x) + Math.abs(this.y - y) + Math.abs(this.z - z)) / 2;\n  }\n\n  directionTo({\n    x,\n    y,\n    z\n  }) {\n    return new Cube(Math.sign(x - this.x), Math.sign(y - this.y), Math.sign(z - this.z));\n  }\n\n  neighborhood() {\n    return Cube.directions.map(dir => this.add(dir));\n  }\n\n}\nCube.directions = [new Cube(+1, -1, 0), new Cube(+1, 0, -1), new Cube(0, +1, -1), new Cube(-1, +1, 0), new Cube(-1, 0, +1), new Cube(0, -1, +1)]; // Space represent board-less plane for stones to be placed on\n// state os space is represented by internal grid, wich is 2d array of tiles\n\nclass Space {\n  constructor(radius) {\n    const len = radius * 2 + 1;\n    this._stones = 0;\n    this._radius = radius;\n    this._grid = Array.from(Array(len), (_, i) => Array.from(Array(len - Math.abs(radius - i)), (_, j) => [] // tile itself si represented by array for stacking multiple stones\n    ));\n  } // return tile of grid on given position or undefined if outside of grid\n\n\n  at({\n    q,\n    r\n  }) {\n    if (Math.abs(q) <= this._radius && Math.abs(r) <= this._radius) {\n      q += this._radius; // center is 0,0\n\n      r += this._radius;\n      return this._grid[r][q - Math.max(0, this._radius - r)];\n    }\n  }\n\n  atTop(pos) {\n    const tile = this.at(pos);\n\n    if (tile && tile.length > 0) {\n      return tile[tile.length - 1];\n    }\n  }\n\n  findBug(check) {\n    return this.hivePositions().map(hex => this.atTop(hex)).find(check);\n  }\n\n  each(callback) {\n    this._grid.forEach((row, i) => {\n      row.forEach((tile, j) => {\n        let r = i;\n        let q = j + Math.max(0, this._radius - i);\n        q -= this._radius; // center is 0,0\n\n        r -= this._radius;\n        callback(tile, new Hex(q, r));\n      });\n    });\n  }\n\n  putAt(bug, dest) {\n    const tile = this.at(dest);\n    let ms = 250;\n\n    let ease = t => t * t;\n\n    if (tile) {\n      let path = bug.pathTo(this, dest);\n      tile.push(bug);\n      const oldTile = this.at(bug.pos);\n\n      if (oldTile && oldTile.length) {\n        // moving\n        const b = oldTile.pop();\n\n        if (b !== bug) {\n          oldTile.push(b);\n          throw Error(`Tried to move bug ${bug.toString()} from tile ${oldTile} but it is not is not ontop`);\n        } // movement speed\n\n\n        ms = 200 / bug.speed;\n        ease = bug.ease;\n      } else {\n        // placing\n        path = [bug.pos, dest];\n        this._stones++;\n      }\n\n      if (!path) {\n        throw Error(`No path found for bug (${bug}) to get to tile (${tile}) at dest (${dest})`);\n      } // animate\n\n\n      const jumps = path.length - 1;\n      const duration = ms * jumps * 1;\n      this.doInTime(duration, t => {\n        t = ease(t);\n        let i = Math.floor(t * jumps); // path segment index\n\n        const diff = i === jumps ? new Hex(0, 0) : path[i + 1].sub(path[i]);\n        bug.pos = path[i].add(diff.scale(t * duration % ms / ms));\n      });\n    }\n  }\n\n  doInTime(duration, doStep) {\n    const start = Date.now();\n    const interval = setInterval(() => {\n      this.animating = true;\n      const sofar = Date.now() - start;\n      doStep(Math.min(sofar / duration, 1));\n    }, 10);\n    setTimeout(() => {\n      clearInterval(interval);\n      doStep(1);\n      this.animating = false;\n    }, duration);\n  } // positions of all occupied tiles\n\n\n  hivePositions() {\n    const positions = [];\n    this.each((tile, hex) => {\n      if (tile.length > 0) {\n        positions.push(hex);\n      }\n    });\n    return positions;\n  } // positions of all tiles which has occupied neigbor tile\n\n\n  nextToHivePositions(except) {\n    const positions = [];\n    this.each((tile, hex) => {\n      if (this.isNextToHive(hex, except)) {\n        positions.push(hex);\n      }\n    });\n    return positions;\n  } // next to hive positions which does not lay next to enemy of given color\n\n\n  safeNextPositions(color) {\n    return this.nextToHivePositions().filter(hex => hex.neighborhood().every(x => !this.isEnemyOf(x, color)));\n  } // return all surrounding on board positions of hex (all 6 except outside of space)\n\n\n  posOfSurroundings(hex) {\n    return hex.neighborhood().filter(pos => Boolean(this.at(pos)));\n  } // positions of all occupied tiles which are in neighborhood of given pos\n\n\n  posOfNeighbors(hex, except) {\n    return hex.neighborhood().filter(pos => {\n      const tile = this.at(pos);\n      return tile && tile.length > 0 && !(except && pos.eq(except));\n    });\n  } // positions of all empty (ongiven level) tiles wich are in neighborhood of given pos\n  // and is accesible without detaching from hive while moving\n  // (has one common neighbor or is on higher elevation)\n\n\n  posOfWays(hex, except, elevation = 0) {\n    return hex.neighborhood().filter(pos => {\n      const dir = hex.directionTo(pos);\n      const left = hex.add(dir.rotate(-1));\n      const right = hex.add(dir.rotate(+1));\n      const currentTile = this.at(hex);\n      const destTile = this.at(pos);\n\n      if (!currentTile || !destTile) {\n        return false;\n      }\n\n      if (destTile.length === elevation) {\n        // dest is empty (on that level)\n        // count empty side tiles\n        const emptySides = [left, right].filter(sidePos => {\n          const sideTile = this.at(sidePos);\n\n          if (!sideTile) {\n            return true; // outside of space is not a way but certainly is empty\n          }\n\n          return except && sidePos.eq(except) ? sideTile.length - 1 <= elevation : sideTile.length <= elevation;\n        }).length;\n\n        if (elevation === 0) {\n          return emptySides === 1; // exactly one of the two sides must be empty on ground\n        } else {\n          return emptySides >= 1; // dont need occupied side bug when on top\n        }\n      }\n    });\n  }\n\n  isEnemyOf(hex, color) {\n    const topBug = this.atTop(hex);\n    return topBug && topBug.color !== color;\n  }\n\n  isNextToHive(hex, except) {\n    // is empty but has occupied neighbor tile\n    return this.at(hex).length === 0 && hex.neighborhood().some(pos => {\n      const tile = this.at(pos);\n      return tile && tile.length > 0 && !(except && pos.eq(except));\n    });\n  } // returns true if bug on given position will break hive on removal\n\n\n  isHiveBridge(hex) {\n    return this.articulations().some(cut => cut.eq(hex));\n  } // Unbreakable 'core' of the hive\n\n\n  articulations() {\n    const hive = this.hivePositions();\n    const M = [];\n    const IN = {};\n    const LOW = {};\n    let T = 0;\n    let rootChilds = 0;\n\n    const dfs = (v, p) => {\n      T++;\n      IN[v] = T;\n      LOW[v] = +Infinity;\n      this.posOfNeighbors(v).forEach(w => {\n        if (!IN[w]) {\n          // vw stromova hrana\n          dfs(w, v);\n\n          if (p) {\n            // non root\n            if (LOW[w] >= IN[v]) {\n              // v je artikulace\n              M.push(v);\n            }\n          } else {\n            // root\n            if (++rootChilds == 2) // pokud ma vice synu, tak je artikulaci \n              M.push(v);\n          }\n\n          LOW[v] = Math.min(LOW[v], LOW[w]);\n        } else if (!w.eq(p || {}) && IN[w] < IN[v]) {\n          // zpetna hrana\n          LOW[v] = Math.min(LOW[v], IN[w]);\n        }\n      });\n    };\n\n    if (hive.length) dfs(hive[0], undefined);\n    return M;\n  }\n\n  findPath(start, goal) {\n    // variation of A* algorithm\n    let frontier = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"PriorityQueue\"]();\n    let cameFrom = {};\n    let costSoFar = {};\n    frontier.push(start, 0);\n    cameFrom[start] = null;\n    costSoFar[start] = 0;\n\n    while (frontier.len() > 0) {\n      let current = frontier.pop();\n\n      if (current.eq(goal)) {\n        break;\n      }\n\n      this.posOfWays(current, start).forEach(next => {\n        let newCost = costSoFar[current] + 1 + this.posOfWays(next).length; // add cost (same for each edge)\n\n        if (!(next in costSoFar) || newCost < costSoFar[next]) {\n          costSoFar[next] = newCost;\n          let priority = newCost + next.distance(goal); // heuristic - use just distance from goal\n\n          frontier.push(next, priority);\n          cameFrom[next] = current;\n        }\n      });\n    } // assemble path from cameFrom\n\n\n    let path = null;\n\n    if (goal in cameFrom) {\n      path = [];\n      let current = goal;\n\n      do {\n        path.unshift(current);\n        current = cameFrom[current];\n      } while (current !== null);\n    }\n\n    return path;\n  } // returns array of hex position where bug of given color can land\n\n\n  possibleLandings({\n    color\n  }) {\n    if (this._stones === 0) {\n      return [new Hex(0, 0), ...Hex.directions];\n    }\n\n    if (this._stones === 1) {\n      return this.nextToHivePositions();\n    }\n\n    return this.safeNextPositions(color);\n  }\n\n  __randomLandingPos(color) {\n    const positions = this.possibleLandings({\n      color\n    });\n    return positions[Object(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"rand\"])(positions.length)] || __randomBugPos(color);\n  }\n\n  __randomBugPos(color) {\n    const positions = this.hivePositions().filter(pos => color === (this.atTop(pos) || {}).color).filter(pos => !this.isHiveBridge(pos) || this.at(pos).length > 1);\n    return positions[Object(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"rand\"])(positions.length)] || new Hex(0, 0);\n  }\n\n  toString() {\n    let str = '';\n    let clr;\n\n    this._grid.forEach((row, i) => {\n      str += '  '.repeat(Math.abs(this._radius - i));\n      row.forEach(tile => {\n        let st = ' ';\n\n        if (tile.length) {\n          st = tile[0].constructor.name[0];\n          if (!clr) clr = tile[0].color;\n\n          if (tile[0].color === clr) {\n            st = st.toLowerCase();\n          }\n        }\n\n        str += `(${st}) `;\n      });\n      str += '\\n';\n    });\n\n    return str;\n  }\n\n}\n\nSpace.fromString = function (string) {\n  return new Space();\n}; // Hand represents storage of stones which are not placed yet.\n\n\nclass Hand {\n  constructor(bugs, revert, offset = 0) {\n    this._hand = [...bugs];\n    bugs.forEach((bug, i) => {\n      bug.pos = new Hex( // -5 + i,\n      // -3 -(i-i%2)/2 - i%2,\n      +8 - i, -7 + offset);\n\n      if (revert) {\n        bug.pos = bug.pos.revert();\n      }\n    });\n  }\n\n  findBug(check) {\n    return this._hand.filter(Boolean).find(check);\n  } // remove bug from hand (if possible)\n\n\n  takeBug(bug) {\n    this.each((b, i) => {\n      if (b === bug) {\n        this._hand[i] = null;\n      }\n    });\n  }\n\n  __getRandomBugPos() {\n    if (this.used() === 3 && this._hand.some(bug => bug && bug.name === 'Queen')) {\n      return this._hand[0].pos; // queen must be used in 4th move\n    }\n\n    const indexes = this._hand.reduce((idxs, v, i) => v !== null ? [...idxs, i] : idxs, []);\n\n    const i = indexes[Object(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"rand\"])(indexes.length)];\n    return this._hand[i].pos;\n  }\n\n  isEmpty() {\n    return !this._hand.some(bug => bug !== null);\n  }\n\n  size() {\n    return this._hand.filter(bug => bug).length;\n  }\n\n  used() {\n    return this._hand.filter(bug => bug === null).length;\n  }\n\n  each(callback) {\n    this._hand.forEach((bug, i) => bug && callback(bug, i, this));\n  }\n\n}\n\n//# sourceURL=webpack:///./board.js?");

/***/ }),

/***/ "./bugs.js":
/*!*****************!*\
  !*** ./bugs.js ***!
  \*****************/
/*! exports provided: Bug, Queen, Beatle, Grasshopper, Spider, Ant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Bug\", function() { return Bug; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Queen\", function() { return Queen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Beatle\", function() { return Beatle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Grasshopper\", function() { return Grasshopper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Spider\", function() { return Spider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ant\", function() { return Ant; });\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass Bug {\n  constructor(color) {\n    _defineProperty(this, \"speed\", 1);\n\n    _defineProperty(this, \"ease\", t => t);\n\n    this.name = this.constructor.name;\n    this.color = color;\n    this.pos = null;\n  }\n\n  toString() {\n    return `${this.color} ${this.name}: ${this.pos}`;\n  }\n\n  reachablePlaces(space) {\n    return space.nextToHivePositions(this.pos).filter(pos => this.canGo(pos, space));\n  }\n\n  canGo(hex, space) {\n    return Boolean(this.pathTo(space, hex));\n  }\n\n  pathTo(space, dest) {\n    if (this.canGo(dest, space)) {\n      return [this.pos, dest];\n    } else {\n      return null;\n    }\n  } // linear\n\n\n} // only one tile per turn\n\nclass Queen extends Bug {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"speed\", 0.6);\n  }\n\n  canGo(hex, space) {\n    return space.posOfWays(this.pos).find(pos => pos.eq(hex));\n  }\n\n} // only one tile per turn\n// can jump on top of other\n// can fit into slit (but only when descending)\n\nclass Beatle extends Bug {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"speed\", 0.3);\n\n    _defineProperty(this, \"ease\", t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t);\n  }\n\n  // in out quad\n  reachablePlaces(space) {\n    return space.posOfSurroundings(this.pos).filter(p => this.canGo(p, space));\n  }\n\n  canGo(hex, space) {\n    const currentTile = space.at(this.pos);\n    const destTile = space.at(hex);\n\n    if (!currentTile || !destTile) {\n      return false;\n    }\n\n    const sameElevation = currentTile.length - 1 === destTile.length;\n\n    if (!sameElevation) {\n      return true; // can go to narrow spaces when changing elevation\n    } else {\n      return space.posOfWays(this.pos, this.pos, currentTile.length - 1).find(pos => pos.eq(hex));\n    }\n  }\n\n} // has to jump over 1 or more bugs in line\n// can fit into slit\n\nclass Grasshopper extends Bug {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ease\", t => t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1);\n\n    _defineProperty(this, \"speed\", 2);\n  }\n\n  pathTo(space, dest) {\n    const cPos = this.pos.toCube();\n    const cDest = dest.toCube();\n    const path = [];\n\n    if (cPos.x !== cDest.x && cPos.y !== cDest.y && cPos.z !== cDest.z) {\n      return null; // not in row\n    }\n\n    if (cPos.distance(cDest) <= 1) {\n      return null; // noone to jump over\n    }\n\n    const dir = cPos.directionTo(cDest);\n\n    for (let seg = cPos; !seg.eq(cDest); seg = seg.add(dir)) {\n      const tile = space.at(seg.toHex());\n\n      if (!tile || tile.length === 0) {\n        return null; // has gap\n      }\n\n      path.push(seg.toHex());\n    }\n\n    path.push(dest);\n    return path;\n  }\n\n} // exactly 3 spaces per turn, no backtracks\n\nclass Spider extends Bug {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ease\", t => t);\n\n    _defineProperty(this, \"speed\", 1.2);\n  }\n\n  pathTo(space, dest) {\n    const path = space.findPath(this.pos, dest);\n\n    if (path && path.length - 1 === 3) {\n      return path;\n    }\n\n    return null;\n  }\n\n} // anywhere\n\nclass Ant extends Bug {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ease\", t => t);\n\n    _defineProperty(this, \"speed\", 1.5);\n  }\n\n  pathTo(space, dest) {\n    let path = space.findPath(this.pos, dest);\n\n    if (path) {\n      return path;\n    }\n\n    return null;\n  }\n\n} // ease = t => t<.5 ? 2*t*t : -1+(4-2*t)*t // ease in out quad\n// ease = t => t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1  // ease in out cubic\n// ease = t => 1-(--t)*t*t*t // ease out quart\n\n//# sourceURL=webpack:///./bugs.js?");

/***/ }),

/***/ "./common.js":
/*!*******************!*\
  !*** ./common.js ***!
  \*******************/
/*! exports provided: rand, PriorityQueue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rand\", function() { return rand; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PriorityQueue\", function() { return PriorityQueue; });\nfunction rand(n) {\n  return Math.floor(Math.random() * n);\n}\nclass PriorityQueue {\n  constructor() {\n    this._que = [];\n  } // lover prio to lover index\n\n\n  push(item, priority) {\n    if (!this._que.some(([_, prio], i) => {\n      if (prio > priority) {\n        this._que.splice(i, 0, [item, priority]);\n\n        return true;\n      }\n    })) {\n      this._que.push([item, priority]);\n    }\n  } // lover prio first\n\n\n  pop() {\n    let [item, _] = this._que.shift();\n\n    return item;\n  }\n\n  len() {\n    return this._que.length;\n  }\n\n}\n\n//# sourceURL=webpack:///./common.js?");

/***/ }),

/***/ "./game.js":
/*!*****************!*\
  !*** ./game.js ***!
  \*****************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Game; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./common.js\");\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./board.js */ \"./board.js\");\n/* harmony import */ var _bugs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bugs.js */ \"./bugs.js\");\n\n\n // class carring state of the game and prviding commands for game interaction\n\nclass Game {\n  constructor(colors, size = 6) {\n    this.state = 'play';\n    this.space = new _board_js__WEBPACK_IMPORTED_MODULE_1__[\"Space\"](size);\n    this.selected = null;\n    this.landings = [];\n    this.invalidated = true;\n    this.players = colors.map((color, i) => ({\n      name: `Player${\"AB\"[i]}`,\n      color,\n      hand: new _board_js__WEBPACK_IMPORTED_MODULE_1__[\"Hand\"](Game.basicBugPack.map(Bug => new Bug(color)), !i)\n    }));\n    this._activePlayerIndex = 0;\n  } // actions\n\n\n  onClick(hex) {\n    if (this.space.animating) {\n      return;\n    }\n\n    if (this.state === 'end') {\n      return;\n    }\n\n    this.invalidated = true;\n\n    if (this.selected && this.landings.some(x => x.eq(hex))) {\n      this.play(hex);\n    } else {\n      this.trySelect(hex);\n    } // console.clear()\n    // console.log(String(game.space))\n    // console.log('hex', String(hex))\n\n  }\n\n  isClickable(hex) {\n    if (this.space.animating) {\n      return false;\n    } // selectable inhand bug\n\n\n    let handBug = this.activePlayer().hand.findBug(bug => bug.pos.eq(hex));\n\n    if (handBug) {\n      if (this.hasToPlaceQueenNow()) {\n        // 3 placed\n        return handBug.name === 'Queen';\n      }\n\n      return true;\n    } // selectable inspace bug\n\n\n    let tile = this.space.at(hex);\n\n    if (tile && tile.length) {\n      let bug = tile[tile.length - 1];\n\n      if (bug.color === this.activePlayer().color && this.isQueenPlaced() && !(tile.length === 1 && this.space.isHiveBridge(bug.pos))) {\n        return true;\n      }\n    } // can land bug\n\n\n    if (this.selected && this.landings.some(x => x.eq(hex))) {\n      return true;\n    }\n  }\n\n  trySelect(hex) {\n    // TODO use isClickable func tokeep it DRY\n    let bug = null; // hand?\n\n    if (bug = this.activePlayer().hand.findBug(bug => bug.pos.eq(hex))) {\n      if (this.hasToPlaceQueenNow() && bug.name !== 'Queen') {\n        return;\n      }\n\n      this.landings = this.space.possibleLandings(bug);\n      this.selected = bug;\n      return;\n    } // tile?\n\n\n    let tile = this.space.at(hex);\n\n    if (tile && tile.length) {\n      bug = tile[tile.length - 1];\n\n      if (bug.color !== this.activePlayer().color) {\n        // deselect\n        bug = null;\n        this.landings = [];\n      } else if (tile.length === 1 && this.space.isHiveBridge(bug.pos)) {\n        bug = null;\n        console.error('cant move this, will break hive into two');\n      } else if (!this.isQueenPlaced()) {\n        bug = null;\n        console.error('cant move - qeen not placed yet');\n      } else if (bug) {\n        // select own\n        this.landings = bug.reachablePlaces(this.space); // TODO\n      }\n    }\n\n    this.selected = bug;\n  } // place or move selected bug\n\n\n  play(hex) {\n    const bug = this.selected;\n    this.activePlayer().hand.takeBug(bug);\n    this.space.putAt(bug, hex);\n    this.selected = null;\n    this.landings = [];\n    this.checkEnd() && (this.state = 'end');\n    this.switchPlayers();\n    console.log(String(this.space));\n  }\n\n  checkEnd() {\n    const dead = this.players.map(player => {\n      const queen = this.space.findBug(({\n        name,\n        color\n      }) => name === 'Queen' && color === player.color);\n      return queen && this.space.posOfNeighbors(queen.pos).length === 6;\n    });\n\n    if (dead[0] && dead[1]) {\n      setTimeout(() => alert('tie'), 200);\n      return true;\n    }\n\n    if (dead[this._activePlayerIndex]) {\n      setTimeout(() => alert('A won'), 200);\n      return true;\n    }\n\n    if (dead[+!this._activePlayerIndex]) {\n      setTimeout(() => alert('B won'), 200);\n      return true;\n    }\n\n    console.log('end?', dead);\n  }\n\n  isQueenPlaced() {\n    return !this.activePlayer().hand.findBug(({\n      name\n    }) => name === 'Queen');\n  }\n\n  hasToPlaceQueenNow() {\n    return this.activePlayer().hand.used() === 3 && // exactly 3 placed\n    !this.isQueenPlaced();\n  }\n\n  switchPlayers() {\n    this._activePlayerIndex = +!this._activePlayerIndex;\n  }\n\n  activePlayer() {\n    return this.players[this._activePlayerIndex];\n  }\n\n  __randomLandingPos() {\n    return this.landings[Object(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"rand\"])(this.landings.length - 1)] || this.space.__randomBugPos(this.activePlayer().color);\n  }\n\n}\nGame.basicBugPack = [_bugs_js__WEBPACK_IMPORTED_MODULE_2__[\"Queen\"], _bugs_js__WEBPACK_IMPORTED_MODULE_2__[\"Spider\"], _bugs_js__WEBPACK_IMPORTED_MODULE_2__[\"Spider\"], _bugs_js__WEBPACK_IMPORTED_MODULE_2__[\"Beatle\"], _bugs_js__WEBPACK_IMPORTED_MODULE_2__[\"Beatle\"], _bugs_js__WEBPACK_IMPORTED_MODULE_2__[\"Ant\"], _bugs_js__WEBPACK_IMPORTED_MODULE_2__[\"Ant\"], _bugs_js__WEBPACK_IMPORTED_MODULE_2__[\"Ant\"], _bugs_js__WEBPACK_IMPORTED_MODULE_2__[\"Grasshopper\"], _bugs_js__WEBPACK_IMPORTED_MODULE_2__[\"Grasshopper\"], _bugs_js__WEBPACK_IMPORTED_MODULE_2__[\"Grasshopper\"]];\n\n//# sourceURL=webpack:///./game.js?");

/***/ }),

/***/ "./hive.js":
/*!*****************!*\
  !*** ./hive.js ***!
  \*****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game.js */ \"./game.js\");\n/* harmony import */ var _ui_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui.js */ \"./ui.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ \"./common.js\");\n\n\n\nconsole.log(\"Hive loaded\");\nconst game = new _game_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](['#112', '#eed'], 5);\n\nif (window.location.href.endsWith(\"autoplay\")) {\n  const autoMove = () => {\n    !game.selected ? game.onClick(Object(_common_js__WEBPACK_IMPORTED_MODULE_2__[\"rand\"])(game.activePlayer().hand.size() + 1) ? game.activePlayer().hand.__getRandomBugPos() : game.space.__randomBugPos(game.activePlayer().color)) : game.onClick(game.__randomLandingPos()); // console.clear()\n    // console.log(String(game.space))\n  };\n\n  const timer = setInterval(autoMove, 150);\n  setTimeout(() => {\n    clearInterval(timer);\n  }, 5 * 60 * 1000);\n}\n\nif (window.location !== window.parent.location) {\n  document.body.style.background = 'none';\n}\n\nconst canvas = document.getElementById('hiveCanvas');\nconst ui = Object(_ui_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(game).on(canvas); // ui.off(canvas)\n// setTimeout(()=>ui.on(canvas), 1500)\n\n//# sourceURL=webpack:///./hive.js?");

/***/ }),

/***/ "./ui.js":
/*!***************!*\
  !*** ./ui.js ***!
  \***************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return uiOf; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./common.js\");\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./board.js */ \"./board.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Everything what has something to do with producing visual output or handling user input is in this file\n\n // returns new Ui class for given space\n\nfunction uiOf(game) {\n  var _temp;\n\n  const S = 64; // size of stone from point to point\n\n  const CNW = 685;\n  const CNH = 685 + 67;\n  const HUE_CLICKABLE = 150;\n  const HUE_LANDING = HUE_CLICKABLE + 35;\n  const SQRT3_2 = Math.sqrt(3) / 2;\n  const SQRT2_3 = Math.sqrt(2) / 3;\n\n  let _ctx;\n\n  let _canvas;\n\n  let _cacheCanvas;\n\n  let _cacheCtx;\n\n  let _frames = 0;\n  let _target = null;\n\n  let _drawQue = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"PriorityQueue\"]();\n\n  return new (_temp = class Ui {\n    constructor() {\n      _defineProperty(this, \"mouseClick\", event => {\n        game.onClick(eventToHex(event));\n      });\n\n      _defineProperty(this, \"mouseMove\", event => {\n        let target = eventToHex(event);\n\n        if (game.isClickable(target)) {\n          _canvas.style.cursor = 'pointer'; // store last hovered tile pos\n\n          _target = target;\n        } else {\n          _canvas.style.cursor = 'default';\n          _target = null;\n        }\n\n        game.invalidated = true;\n      });\n\n      _defineProperty(this, \"keyPress\", event => {\n        const handBug = game.activePlayer().hand.findBug(bug => bug.name[0].toLowerCase() === event.key);\n\n        if (handBug) {\n          return game.onClick(handBug.pos);\n        }\n\n        const spaceBug = game.space.findBug(bug => bug.name[0].toLowerCase() === event.key && bug.color === game.activePlayer().color && bug !== game.selected && !game.space.isHiveBridge(bug.pos));\n\n        if (spaceBug) {\n          return game.onClick(spaceBug.pos);\n        }\n      });\n\n      _defineProperty(this, \"onFrame\", t => {\n        if (_frames++ % 2 === 0) // 30fps\n          this.redraw(t);\n        if (!this.stop) requestAnimationFrame(this.onFrame);\n      });\n    }\n\n    async on(canvas) {\n      _canvas = canvas;\n      _ctx = setupCanvasHDPI(_canvas, CNW, CNH, {\n        alpha: true\n      });\n      _cacheCanvas = document.createElement('canvas'); // _canvas.cloneNode()\n\n      game.space.each((tile, hex) => drawTile(tile, hex));\n      _cacheCanvas.with = _canvas.with;\n      _cacheCanvas.height = _canvas.height;\n      _cacheCtx = setupCanvasHDPI(_cacheCanvas, CNW, CNH, {\n        _willReadFrequently: true\n      }); // prepare background\n\n      _cacheCtx.filter = \"brightness(120%) contrast(20%) blur(2px)\";\n      game.space.each((tile, hex) => drawTile(tile, hex, _cacheCtx));\n      canvas.addEventListener('mousemove', this.mouseMove);\n      canvas.addEventListener('mousedown', this.mouseClick);\n      document.addEventListener('keypress', this.keyPress);\n      this.startAnimation();\n      return this;\n    }\n\n    off(canvas) {\n      this.stopAnimation();\n      canvas = canvas || _canvas;\n      canvas.removeEventListener('mousemove', this.mouseMove);\n      canvas.removeEventListener('mousedown', this.mouseClick);\n      document.removeEventListener('keypress', this.keyPress);\n      return this;\n    }\n\n    startAnimation() {\n      this.stop = false;\n      game.invalidated = true;\n      requestAnimationFrame(this.onFrame);\n    }\n\n    stopAnimation() {\n      this.stop = true;\n    }\n\n    redraw(t) {\n      if (game.invalidated || game.space.animating || this._oneMoreFrame) {\n        // backgrond\n        drawBackground(); // bugs\n\n        game.space.each(drawBugsOftile);\n        game.players.forEach(({\n          hand\n        }) => hand.each(b => drawBug(b, undefined, true))); // outlines\n\n        if (game.selected) {\n          drawOutline(game.selected.pos, HUE_CLICKABLE);\n          game.landings.forEach(pos => {\n            drawOutline(pos, HUE_LANDING);\n          });\n          _target && game.selected && (game.selected.pathTo(game.space, _target) || []).forEach((pos, i) => {\n            i > 0 && _drawQue.push(() => drawDot(pos, HUE_LANDING), 3);\n          });\n        } // end\n\n\n        if (this._oneMoreFrame) {\n          this._oneMoreFrame = false;\n        }\n\n        game.invalidated = false;\n      } // render always:\n\n\n      let p1 = new _board_js__WEBPACK_IMPORTED_MODULE_1__[\"Hex\"](-10, 5);\n      let p2 = p1.rotate(-1);\n      drawLoader(t, p1, game.players[0]);\n      drawLoader(t, p2, game.players[1]); // call deffered drawing stuff\n\n      while (_drawQue.len() > 0) {\n        _drawQue.pop()();\n      }\n\n      if (game.invalidated || game.space.animating) {\n        this._oneMoreFrame = true;\n      }\n    }\n\n  }, _temp)(); // canvas related functions\n\n  function setupCanvasHDPI(canvas, w, h, options) {\n    let ratio = window.devicePixelRatio || 1;\n\n    if (ratio > 2) {\n      ratio /= 2; // it would be too much pixels to render for mobiles with dpr 3 or more\n    }\n\n    canvas.width = w * ratio;\n    canvas.height = h * ratio;\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n    let ctx = canvas.getContext('2d', options);\n    ctx.scale(ratio, ratio);\n    return ctx;\n  }\n\n  function drawBackground() {\n    _ctx.clearRect(0, 0, CNW, CNH);\n\n    _ctx.drawImage(_cacheCanvas, 0, 0, CNW, CNH);\n  }\n\n  function hexToScreen({\n    q,\n    r\n  }) {\n    // let x = S/2 * (    3/2 * q                   )\n    // let y = S/2 * (SQRT3_2 * q + Math.sqrt(3) * r)\n    let x = S / 2 * (Math.sqrt(3) * q + SQRT3_2 * r);\n    let y = S / 2 * (3 / 2 * r);\n    x += CNW / 2;\n    y += CNH / 2;\n    return {\n      x,\n      y\n    };\n  }\n\n  function screenToHex({\n    x,\n    y\n  }) {\n    x -= CNW / 2;\n    y -= CNH / 2; // let q = ( 2/3 * x                     ) / (S/2)\n    // let r = (-1/3 * x + Math.sqrt(3)/3 * y) / (S/2)\n\n    let q = (Math.sqrt(3) / 3 * x - 1 / 3 * y) / (S / 2);\n    let r = 2 / 3 * y / (S / 2);\n    return new _board_js__WEBPACK_IMPORTED_MODULE_1__[\"Hex\"](q, r);\n  }\n\n  function eventToHex({\n    offsetX: x,\n    offsetY: y\n  }) {\n    return screenToHex({\n      x,\n      y\n    }).round();\n  }\n\n  function drawTile(tile, hex, ctx) {\n    ctx = ctx || _ctx;\n    const {\n      x,\n      y\n    } = hexToScreen(hex);\n    const delta = hex.distance(new _board_js__WEBPACK_IMPORTED_MODULE_1__[\"Hex\"](0, 0));\n    const cube = hex.toCube();\n    const [r, g, b] = [cube.x * 45, cube.z * 45, cube.y * 45];\n    ctx.strokeStyle = ctx.fillStyle = `rgba(${r},${g},${b},${0.2 + 0.1 * delta})`;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    hexPath(ctx, x, y, S / 2);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n  }\n\n  function drawBugsOftile(tile, hex) {\n    const offset = new _board_js__WEBPACK_IMPORTED_MODULE_1__[\"Hex\"](+0.0, -0.2);\n    tile.forEach((b, i) => {\n      const isTop = i === tile.length - 1;\n\n      const draw = () => drawBug(b, b.pos.add(offset.scale(i)), isTop);\n\n      const isMoving = !hex.eq(b.pos);\n\n      if (i === 0 && !isMoving) {\n        // bottom most and the not moving ones draw normally\n        draw();\n      } else {\n        // deffer top layers\n        _drawQue.push(draw, isMoving ? 2 : 1 // moving on top\n        );\n      }\n    });\n  }\n\n  function drawBug(bug, pos = bug.pos, isTop) {\n    let {\n      x,\n      y\n    } = hexToScreen(pos);\n    let r = S / 2;\n\n    if (_target && bug.pos.eq(_target) && isTop || // hover\n    game.selected === bug // selected\n    ) {\n        r *= 1.25;\n      }\n\n    {\n      // stone\n      hexPath(_ctx, x, y, r);\n\n      let grad = _ctx.createLinearGradient(x - r, y - r, x + r, y + r);\n\n      grad.addColorStop(0, bug.color === game.players[1].color ? '#fff' : '#666');\n      grad.addColorStop(1, bug.color === game.players[1].color ? '#999' : '#000');\n      _ctx.fillStyle = grad;\n\n      _ctx.fill();\n\n      _ctx.lineWidth = 1;\n      _ctx.lineJoin = 'round';\n      _ctx.strokeStyle = '#808080';\n\n      _ctx.stroke();\n\n      _ctx.beginPath();\n\n      _ctx.moveTo(x, y + r);\n\n      _ctx.arc(x, y, r * SQRT3_2 - 2, 0, Math.PI * 2);\n\n      _ctx.closePath();\n\n      _ctx.fillStyle = bug.color;\n\n      _ctx.fill();\n    }\n    {\n      // text\n      const txt = bug.constructor.name.substr(0, 6);\n      _ctx.textBaseline = 'middle';\n      _ctx.font = 'normal 16px monospace';\n\n      if (bug.name === \"Queen\") {\n        _ctx.font = 'bold 18px monospace';\n        _ctx.fontWeigh = \"bold\";\n      }\n\n      const w = _ctx.measureText(txt).width;\n\n      _ctx.fillStyle = '#808080';\n\n      _ctx.fillText(txt, x - w / 2, y);\n    }\n\n    if (isTop && game.isClickable(bug.pos)) {\n      _drawQue.push(() => drawOutline(pos, HUE_CLICKABLE), 0);\n    }\n  }\n\n  function drawDot(pos, hue) {\n    let r = S / 6;\n    const {\n      x,\n      y\n    } = hexToScreen(pos);\n    hexPath(_ctx, x, y, r - 2);\n    _ctx.strokeStyle = `hsla(${hue}, 80%, 50%, 1)`;\n    _ctx.lineWidth = 2;\n    _ctx.lineCap = 'round';\n\n    _ctx.stroke();\n  }\n\n  function drawOutline(pos, hue) {\n    let r = S / 2;\n    const dimm = hue === HUE_CLICKABLE && game.selected && !game.selected.pos.eq(pos.round());\n\n    if (_target && pos.round().eq(_target) && game.isClickable(_target) || // hover\n    game.selected && pos.round().eq(game.selected.pos) // selected\n    ) {\n        r *= 1.25;\n      }\n\n    const {\n      x,\n      y\n    } = hexToScreen(pos);\n\n    _ctx.beginPath();\n\n    hexPath(_ctx, x, y, r - 3.5);\n    _ctx.strokeStyle = `hsla(${hue}, 80%, 50%, ${dimm ? 0.25 : 1})`;\n    _ctx.lineWidth = 4;\n    _ctx.lineCap = 'round';\n\n    _ctx.stroke();\n  }\n\n  function drawLoader(t, pos, player) {\n    t /= 2000;\n    const a = t % 1 * Math.PI * 4 - Math.PI / 2;\n    const b = t / 2 % 1 * Math.PI * 4 - Math.PI / 2;\n    let {\n      x,\n      y\n    } = hexToScreen(pos);\n    const txtLim = 10;\n    const name = player.name.length <= txtLim ? player.name : player.name.substr(0, txtLim - 1) + 'â€¦';\n    _ctx.font = 'normal 16px monospace';\n\n    const txtW = _ctx.measureText(name).width;\n\n    const txtOfst = 6;\n    const s = S * SQRT3_2;\n    const r = s / 3;\n    x += s * 2;\n\n    _ctx.clearRect(x - r - 4, y - r - 4, r * 2 + txtW + txtOfst + 8, r * 2 + 8); // circle\n\n\n    if (player === game.activePlayer()) {\n      _ctx.beginPath();\n\n      _ctx.arc(x, y, r * SQRT2_3 + 2, a, b, a < b);\n\n      _ctx.strokeStyle = `hsla(${t * 200 % 360}, 25%, 50%, 1)`;\n      _ctx.lineCap = 'round';\n      _ctx.lineWidth = 10;\n\n      _ctx.stroke();\n    } // hex:\n\n\n    {\n      hexPath(_ctx, x, y, r - 0.5);\n      _ctx.strokeStyle = player.color;\n      _ctx.lineCap = 'round';\n      _ctx.lineWidth = 7;\n\n      _ctx.stroke();\n\n      hexPath(_ctx, x, y, r + 2.5);\n      _ctx.strokeStyle = '#808080';\n      _ctx.lineCap = 'round';\n      _ctx.lineWidth = 1;\n\n      _ctx.stroke();\n\n      x += txtOfst + r; // { // name label\n      //   let r = s/2 - 12\n      //   _ctx.beginPath()\n      //   _ctx.moveTo(x, y-r)\n      //   _ctx.lineTo(x+txtW, y-r)\n      //   _ctx.lineTo(x+SQRT3_2*r+txtW, y - SQRT2_3 * r)\n      //   _ctx.lineTo(x+SQRT3_2*r+txtW, y + SQRT2_3 * r)\n      //   _ctx.lineTo(x+txtW, y+r)\n      //   _ctx.lineTo(x, y+r)\n      //   _ctx.lineTo(x-SQRT3_2*r,  y + SQRT2_3 * r)\n      //   _ctx.lineTo(x-SQRT3_2*r,  y - SQRT2_3 * r)\n      //   _ctx.closePath()\n      //   _ctx.fillStyle = player.color\n      //   // _ctx.fillStyle = '#808080'\n      //   _ctx.lineCap = 'round'\n      //   _ctx.fill()\n      //   _ctx.stroke()\n      // }\n    } // name text:\n\n    {\n      _ctx.textBaseline = 'middle';\n      _ctx.font = 'bold 15px monospace';\n      _ctx.fillStyle = '#808080'; // _ctx.fillStyle = player.color\n\n      _ctx.fillText(name, x, y);\n    }\n  }\n\n  function hexPath(ctx, x, y, r) {\n    ctx.beginPath();\n    ctx.moveTo(x, y - r);\n    ctx.lineTo(x + SQRT3_2 * r, y - SQRT2_3 * r);\n    ctx.lineTo(x + SQRT3_2 * r, y + SQRT2_3 * r);\n    ctx.lineTo(x, y + r);\n    ctx.lineTo(x - SQRT3_2 * r, y + SQRT2_3 * r);\n    ctx.lineTo(x - SQRT3_2 * r, y - SQRT2_3 * r);\n    ctx.closePath();\n  }\n}\n\n//# sourceURL=webpack:///./ui.js?");

/***/ })

/******/ });